#!/bin/bash

# Enhanced Pre-Commit Hook v2.0
# Implements: COLLABORATION FIRST, KISS, Security First, Quality First, ENGLISH FOR CODE
# Project: Basser MVP
# Author: Basser Development Agents Team
# Date: December 8, 2025

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Print colored message
print_message() {
    local color=$1
    local message=$2
    echo -e "${color}${message}${NC}"
}

# Print section header
print_header() {
    echo ""
    print_message "$BLUE" "=================================================="
    print_message "$BLUE" "$1"
    print_message "$BLUE" "=================================================="
    echo ""
}

# Check if command exists
command_exists() {
    command -v "$1" >/dev/null 2>&1
}

# Main execution
main() {
    print_header "ğŸ” Pre-Commit Hook v2.0"
    
    print_message "$BLUE" "Running pre-commit checks..."
    echo ""
    
    # 1. Check for Flutter
    if ! command_exists flutter; then
        print_message "$RED" "âŒ Flutter not found"
        exit 1
    fi
    
    # 2. Format check
    print_header "ğŸ“ Code Formatting"
    print_message "$BLUE" "Checking code formatting..."
    
    if ! dart format --set-exit-if-changed . >/dev/null 2>&1; then
        print_message "$YELLOW" "âš ï¸  Code formatting issues found. Auto-formatting..."
        dart format .
        print_message "$GREEN" "âœ… Code formatted. Please review and commit again."
        exit 1
    fi
    print_message "$GREEN" "âœ… Code formatting OK"
    
    # 3. Static analysis
    print_header "ğŸ” Static Analysis"
    print_message "$BLUE" "Running flutter analyze..."
    
    if ! flutter analyze --no-fatal-infos; then
        print_message "$RED" "âŒ Static analysis failed"
        print_message "$YELLOW" "ğŸ’¡ Fix the issues above and try again"
        exit 1
    fi
    print_message "$GREEN" "âœ… Static analysis passed"
    
    # 4. Check for hardcoded secrets (Security First)
    print_header "ğŸ”’ Security Checks"
    print_message "$BLUE" "Checking for hardcoded secrets..."
    
    # Get staged files
    staged_files=$(git diff --cached --name-only --diff-filter=ACM | grep -E '\.(dart|yaml|json)$' || true)
    
    if [ -n "$staged_files" ]; then
        # Check for common secret patterns
        secret_patterns=(
            "password\s*=\s*['\"][^'\"]+['\"]"
            "api[_-]?key\s*=\s*['\"][^'\"]+['\"]"
            "secret\s*=\s*['\"][^'\"]+['\"]"
            "token\s*=\s*['\"][^'\"]+['\"]"
            "sk_live_"
            "sk_test_"
        )
        
        found_secrets=false
        for pattern in "${secret_patterns[@]}"; do
            if echo "$staged_files" | xargs grep -iE "$pattern" 2>/dev/null; then
                found_secrets=true
                break
            fi
        done
        
        if [ "$found_secrets" = true ]; then
            print_message "$RED" "âŒ Potential hardcoded secrets found!"
            print_message "$YELLOW" "ğŸ’¡ Use environment variables or secure storage instead"
            exit 1
        fi
    fi
    print_message "$GREEN" "âœ… No hardcoded secrets found"
    
    # 5. Check commit message format (COLLABORATION FIRST)
    print_header "ğŸ“ Commit Message"
    print_message "$BLUE" "Checking commit message format..."
    
    # Get commit message
    commit_msg_file=".git/COMMIT_EDITMSG"
    if [ -f "$commit_msg_file" ]; then
        commit_msg=$(head -n 1 "$commit_msg_file")
        
        # Check conventional commits format
        if ! echo "$commit_msg" | grep -qE "^(feat|fix|docs|style|refactor|test|chore|perf|ci|build)(\(.+\))?: .+"; then
            print_message "$YELLOW" "âš ï¸  Commit message doesn't follow Conventional Commits format"
            print_message "$YELLOW" "ğŸ’¡ Format: type(scope): description"
            print_message "$YELLOW" "ğŸ’¡ Example: feat(customers): add search functionality"
        else
            print_message "$GREEN" "âœ… Commit message format OK"
        fi
    fi
    
    # 6. Check for ENGLISH FOR CODE principle
    print_header "ğŸŒ Language Check"
    print_message "$BLUE" "Checking for English code..."
    
    if [ -n "$staged_files" ]; then
        # Check for non-English variable/function names (basic check)
        if echo "$staged_files" | xargs grep -E "[\u0600-\u06FF]" 2>/dev/null | grep -v "// " | grep -v "/// " | grep -v "String" | grep -v "Text(" >/dev/null; then
            print_message "$YELLOW" "âš ï¸  Non-English characters found in code (outside comments/strings)"
            print_message "$YELLOW" "ğŸ’¡ Use English for all code, variables, and function names"
        else
            print_message "$GREEN" "âœ… Code language check passed"
        fi
    fi
    
    # 7. Check for KISS principle violations
    print_header "ğŸ¯ KISS Principle Check"
    print_message "$BLUE" "Checking for overly complex code..."
    
    if [ -n "$staged_files" ]; then
        # Check for very long functions (>100 lines)
        long_functions=$(echo "$staged_files" | xargs grep -n "^\s*\(void\|Future\|int\|String\|bool\|double\)" 2>/dev/null | \
            awk -F: '{print $1":"$2}' | \
            while read line; do
                file=$(echo "$line" | cut -d: -f1)
                start=$(echo "$line" | cut -d: -f2)
                # Simple heuristic: check if function is >100 lines
                end=$(tail -n +$start "$file" | grep -n "^\s*}" | head -1 | cut -d: -f1)
                if [ -n "$end" ] && [ $end -gt 100 ]; then
                    echo "$file:$start (${end} lines)"
                fi
            done)
        
        if [ -n "$long_functions" ]; then
            print_message "$YELLOW" "âš ï¸  Very long functions found (>100 lines):"
            echo "$long_functions"
            print_message "$YELLOW" "ğŸ’¡ Consider breaking down into smaller functions (KISS principle)"
        else
            print_message "$GREEN" "âœ… No overly complex functions found"
        fi
    fi
    
    # Success
    print_header "âœ… Pre-Commit Checks Passed!"
    
    print_message "$GREEN" "ğŸ‰ All checks passed!"
    print_message "$BLUE" "ğŸ“ Proceeding with commit..."
    
    echo ""
    print_message "$BLUE" "Principles Applied:"
    print_message "$GREEN" "- âœ… COLLABORATION FIRST: Clear feedback on issues"
    print_message "$GREEN" "- âœ… KISS: Simple, focused checks"
    print_message "$GREEN" "- âœ… Security First: Secret detection"
    print_message "$GREEN" "- âœ… Quality First: Format and analysis checks"
    print_message "$GREEN" "- âœ… ENGLISH FOR CODE: Language validation"
}

# Run main function
main "$@"
